// Generated by CoffeeScript 1.7.1
var CUBIC_METERS_FACTOR, EXTENSION, FORCED_COLORS, IGNORE, LABEL_PADDING, TRUNCATE_DATE, area, boundingBox, canvasHeight, canvasWidth, drawLineGraph, margin, parseDate, stack, stringToHex, svg, xAxis, xScale, yAxis, yScale,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

margin = {
  top: 20,
  bottom: 20,
  left: 20,
  right: 20
};

canvasWidth = 1100 - margin.left - margin.right;

canvasHeight = 600 - margin.top - margin.bottom;

svg = d3.select("#vis").append("svg").attr("width", canvasWidth + margin.left + margin.right).attr("height", canvasHeight + margin.top + margin.top).append("g").attr("transform", "translate(" + margin.left + ", " + margin.top + ")");

boundingBox = {
  x: 120,
  y: 0,
  width: canvasWidth - 100,
  height: canvasHeight - 50
};

FORCED_COLORS = {
  "MEA": "#377eb8",
  "ORO": "#ffed6f",
  "SNL": "#e41a1c",
  "LUS": "#e41a1c",
  "NML": "#f16913",
  "BER": "#ffd92f",
  "CLE": "#54278f",
  "SHA": "#fcc5c0"
};

IGNORE = ["dates"];

LABEL_PADDING = 7;

EXTENSION = "qwert";

TRUNCATE_DATE = "07/1957";

CUBIC_METERS_FACTOR = 1233.4892384681;

parseDate = d3.time.format("%m/%Y").parse;

stringToHex = function(str) {
  var code, decimal, hexadecimal, hexatridecimal, reservoir, trimmed, truncated;
  for (reservoir in FORCED_COLORS) {
    if (str.slice(0, 3) === reservoir) {
      return FORCED_COLORS[reservoir];
    }
  }
  hexatridecimal = parseInt(str, 36);
  trimmed = hexatridecimal.toExponential().slice(2, -5);
  decimal = parseInt(trimmed, 10);
  truncated = decimal & 0xFFFFFF;
  hexadecimal = truncated.toString(16).toUpperCase();
  code = "#" + (('000000' + hexadecimal).slice(-6));
  return code;
};

xScale = d3.time.scale().range([0, boundingBox.width]);

yScale = d3.scale.linear().range([boundingBox.height, 0]);

xAxis = d3.svg.axis().scale(xScale).orient("bottom");

yAxis = d3.svg.axis().scale(yScale).orient("left");

stack = d3.layout.stack().offset("zero").order("inside-out").values(function(d) {
  return d.values;
}).x(function(d) {
  return d.date;
}).y(function(d) {
  return d.storage;
});

area = d3.svg.area().interpolate("linear").x(function(d) {
  return xScale(d.date);
}).y0(function(d) {
  return yScale(d.y0);
}).y1(function(d) {
  return yScale(d.y0 + d.y);
});

drawLineGraph = function(dataset, dates) {
  var areas, frame, layers, record, storage, storages, value, _i, _j, _len, _len1, _ref;
  layers = stack(dataset);
  xScale.domain(d3.extent(dates));
  storages = [];
  for (_i = 0, _len = dataset.length; _i < _len; _i++) {
    record = dataset[_i];
    _ref = record.values;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      value = _ref[_j];
      storage = value.y0 + value.y;
      if (__indexOf.call(storages, storage) < 0) {
        storages.push(storage);
      }
    }
  }
  yScale.domain([0, d3.max(storages)]);
  frame = svg.append("g").attr("transform", "translate(" + boundingBox.x + ", " + boundingBox.y + ")");
  frame.append("g").attr("class", "x axis").attr("transform", "translate(0, " + boundingBox.height + ")").call(xAxis);
  frame.append("g").attr("class", "y axis").call(yAxis);
  areas = frame.selectAll(".area").data(layers).enter().append("path").attr("class", "area").attr("d", function(d) {
    return area(d.values);
  }).style("fill", function(d) {
    return stringToHex(d.key + EXTENSION);
  });
  frame.append("text").attr("class", "x label").attr("text-anchor", "end").attr("x", boundingBox.width - LABEL_PADDING).attr("y", boundingBox.height - LABEL_PADDING).text("Date");
  frame.append("text").attr("class", "y label").attr("text-anchor", "end").attr("y", LABEL_PADDING).attr("dy", ".75em").attr("transform", "rotate(-90)").text("Storage (mÂ³)");
  return areas.on("mouseover", function(d) {
    return console.log(d.key);
  });
};

d3.json("monthly-reservoir-storage.json", function(data) {
  var dataset, date, dates, filledDataset, filledRecord, found, interpolatedData, interpolator, localStorages, localTimes, point, record, records, relevantTimes, reservoir, storage, time, times, truncatedDates, value, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2;
  dates = [];
  _ref = data.dates;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    date = _ref[_i];
    dates.push(parseDate(date));
  }
  dataset = [];
  for (reservoir in data) {
    values = data[reservoir];
    if (__indexOf.call(IGNORE, reservoir) < 0) {
      records = {
        "key": reservoir,
        "values": []
      };
      for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
        value = values[_j];
        storage = value.storage;
        if (storage === "--") {
          continue;
        } else {
          storage = Math.round(+storage * CUBIC_METERS_FACTOR);
        }
        date = parseDate(value.date);
        records.values.push({
          "date": date,
          "storage": storage
        });
      }
      dataset.push(records);
    }
  }
  times = [];
  for (_k = 0, _len2 = dates.length; _k < _len2; _k++) {
    date = dates[_k];
    times.push(date.getTime());
  }
  for (_l = 0, _len3 = dataset.length; _l < _len3; _l++) {
    record = dataset[_l];
    reservoir = record.key;
    localTimes = [];
    localStorages = [];
    _ref1 = record.values;
    for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
      point = _ref1[_m];
      localTimes.push(point.date.getTime());
      localStorages.push(point.storage);
    }
    interpolator = d3.scale.linear().domain(localTimes).range(localStorages);
    interpolatedData = [];
    relevantTimes = times.slice(times.indexOf(localTimes[0]), +times.indexOf(localTimes[localTimes.length - 1]) + 1 || 9e9);
    for (_n = 0, _len5 = relevantTimes.length; _n < _len5; _n++) {
      time = relevantTimes[_n];
      storage = Math.round(interpolator(time));
      interpolatedData.push({
        "date": new Date(time),
        "storage": storage
      });
    }
    record.values = interpolatedData;
  }
  truncatedDates = [];
  for (_o = 0, _len6 = dates.length; _o < _len6; _o++) {
    date = dates[_o];
    if (date.getTime() >= parseDate(TRUNCATE_DATE).getTime()) {
      truncatedDates.push(date);
    }
  }
  dates = truncatedDates;
  filledDataset = [];
  for (_p = 0, _len7 = dataset.length; _p < _len7; _p++) {
    record = dataset[_p];
    filledRecord = {
      "key": record.key,
      "values": []
    };
    for (_q = 0, _len8 = dates.length; _q < _len8; _q++) {
      date = dates[_q];
      found = false;
      _ref2 = record.values;
      for (_r = 0, _len9 = _ref2.length; _r < _len9; _r++) {
        value = _ref2[_r];
        if (value.date.getTime() === date.getTime()) {
          filledRecord.values.push(value);
          found = true;
          break;
        }
        if (value.date.getTime() > date.getTime()) {
          break;
        }
      }
      if (!found) {
        filledRecord.values.push({
          "date": date,
          "storage": 0
        });
      }
    }
    filledDataset.push(filledRecord);
  }
  return drawLineGraph(filledDataset, dates);
});
